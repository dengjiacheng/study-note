      JAVA虚拟机在执行java程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域。

### 程序计数器
>当前线程所执行字节码的行号指示器。当程序计数器指向一个本地（native）方法,这个计数器的值为空，这个内存区域是java虚拟机规范中唯一一个没有规定任何OutOfMemoryError情况的区域。每个线程都有自己的程序计数器。
***

### Java虚拟机栈
>虚拟机栈是描述java方法执行的内存模型。每个方法在执行的同时都会创建一栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用到执行结束，就对应着一个栈帧的入栈出栈过程。
* #### 局部变量表
>存放了在编译期可知的各种基本数据类型、对象引用、returnAddress类型。在进入一个方法的时候，这个方法需要在栈中分配多大的局部变量表是确定的，在运行期间是不会改变局部变量表的大小。

>线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverFlowError异常。无法申请到足够的虚拟机内存将抛出异常OutOfMemoryError异常。
***

### 本地方法栈
>本地方法栈所发挥的作用与虚拟机栈非常相似，他们之间的区别在于虚拟机栈为虚拟机执行java方法（字节码）服务，而本地方法栈是为虚拟机使用到的native方法服务。

>与虚拟机栈一样本地方法栈也会抛出StackOverFlowError异常与OutOfMemoryError异常。
***

### Java堆
> 线程共享的，几乎存放了所有的实力对象与数组。如果在堆中没有内存完成实例分配，抛出异常OutOfMemoryError异常。
***

### 方法区

> 方法区与java堆一样，是各个线程共享的内存区域。它用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。


- ##### 运行时常量池

> 运行时常量池是方法区的一部分。用于存储编译期生成的字面量、符号引用。这部分内容在将在类加载后进入运行时常量池。常量池是动态的。例如String de intern()方法直接将字面量放入常量池，当常量池无法再申请到内存时会抛出异常OutOfMemoryError异常。
***


### 直接内存

> 直接内存**不是**虚拟机运行时内存区域的一部分，在JDK1.4中新加入的NIO类，引入了一种基于通道（channel）与缓冲区（Buffer）的I/O方式。它可以使用Native函数库直接分配对内存。然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用来进行操作。避免在java堆中与Native堆中来回复制数据。显著提升性能。

> 可能爬出异常OutOfMemoryError异常。
***
